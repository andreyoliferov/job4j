package ru.oliferov.beans.example;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.*;
import org.springframework.core.env.Environment;

/**
 * @autor aoliferov
 * @since 07.03.2019
 */
/**
 * http://spring-projects.ru/guides/lessons/lesson-2/
 * Конфигурационный класс Spring IoC контейнера
 */
@Configuration
@Conditional(ToConditionalClass.class) /*задание условий для работы этой конфигурации (или бину), условие указывается
классом ToConditionalClass, который реализует интерфейс Condition*/
@Import(AnotherConfiguration.class)
@ImportResource("classpath:spring-context.xml")
@PropertySource("classpath:postgres.properties") //подгружаем свойства, обратиться с getProperty можно к переменной env
@ComponentScan("ru.oliferov.beans") //сканирование папки на аннотацию @Component для создания бинов
public class MyConfig {

    @Autowired
    Environment env;

    /*Джава-конфигурирование позволяет выполнять абсолютно любой джава-код в методах по созданию бинов.
     Можно делать реально что угодно: создавать другие вспомогательные объекты, вызывать любые другие методы, даже не
     помеченные спринговыми анотациями, делать циклы, условия - что только в голову придет!*/

    @Bean //можно явно указать имя ("name")
    @Scope("singleton")/* ("prototype") создание отдельного экземпляра при каждом вызове
     из контекста или вызове зависимости */
    @Description("Текстовое описание бина greetingService")
    public Store getStore() {
        String prop = env.getProperty("db.username");
        return new Store();
    }

    @Profile("dev") /*бины можно делить по профилям, для того что бы работали бины профиля этот профиль должен быть
     активным (можно задать через переменную среды spring.profiles.default или для объекта контекста)*/
    @Bean(initMethod = "initMethod", destroyMethod = "destroyMethod")
    public UserStore getUserStore(@Qualifier("nameStore") Store store) { /*бин store при создании подгрузится
    автоматически, если подходящих бинов несколько то id нужного бина через Qualifier указать явно */
        return new UserStore(store);
    }

    private void initMethod() {

    }

//    Резюме:
//    стараться использовать автоматическую конфигурацию;
//    при автоматической конфигурации указываем имя пакета, где лежат классы, бины которых надо создать;
//    такие классы помечаются аннотацией @Component;
//    спринг проходит по всем таким классам и создает их объекты и помещает себе в контекст;
//    если автоматическая конфиграция нам по каким-то причинам не подходит — используем java-конфигурирование;
//    в таком случае создаем обычный джава класс, методы которого будут возвращать нужные нам объекты, и помечаем такой
//    класс аннотацией @Configuration на случай, если будем сканировать весь пакет целиком, а не указывать конкретный
//    класс с конфигурацией при создании контекста;
//    методы этого класса, которые возвращают бины — помечаем аннотацией @Bean;
//    если хотим подключить возможность автоматического сканирования при использовании java-конфигурации — используем
//    аннотацию @ComponentScan.

    //Полный @Configuration vs легкий @Bean режимы
    //Когда методы с аннотацией @Bean определены в классах, не имеющих аннотацию @Configuration, то относятся к
    // обработке в легком режиме, то же относится и к классам с аннотацией @Component. Иначе, такие методы относятся к
    // полному режиму обработки.
    //В отличие от полного, в легком режиме @Bean методы не могут просто так объявлять внутренние зависимости.
    // Поэтому, в основном предпочтительно работать в полном режиме, во избежание трудноуловимых ошибок.

    //Именовать бины принято в соответствии со стандартным соглашением по именованию полей Java-классов. Т.е. имена
    // бинов должны начинаться со строчной буквы и быть в "Верблюжьей" нотации.

    //Другой основной аннотацией является @Component, а также её наследники @Repository, @Service и @Controller.
    // Все они являются общими шаблонами для любых компонентов, управляемыми контейнеером. @Repository, @Service и
    // @Controller рекомендуется использовать в тех случаях, когда вы можете отнести аннотируемый класс к определенному
    // слою, например DAO, либо когда вам необходима поддержка функциональности, которую предоставляет аннотация.
    // Также эти аннотации могут иметь дополнительный смысл в будущих версиях Spring Framework. В остальных же
    // случаях достаточно использовать аннотацию @Component.

    //Стоит упомянуть ещё одну мета-аннотацию @Required. Данная аннотация применяется к setter-методу бина и указывает
    // на то, чтобы соответствующее свойство метода было установлено на момент конфигурирования значением из определения
    // бина или автоматического связывания. Если же значение не будет установлено, будет выброшено исключение.


//    Вы можете контролировать не только какие зависимости и значения конфигурации вы можете подключить в объекте,
//    который создан из определения бина, но также область видимости из того же определения бина. Это мощный и гибкий
//    подход, при котором вы можете выбрать область видимости создаваемых объектов. Изначально, Spring Framework
//    поддерживает несколько вариантов, некоторые доступны, только если вы используете web-aware ApplicationContext.
//    Также вы можете создать свою собственную облать видимости. Ниже приведен список областей видимостей, описанных в
//    документации на момент написания урока:
//
//    singleton - По умолчанию. Spring IoC контейнер создает единственный экземпляр бина.
//             Как правило, используется для бинов без сохранения состояния(stateless)
//    prototype - Spring IoC контейнер создает любое количество экземпляров бина. Новый экземпляр бина создается каждый
//             раз, когда бин необходим в качестве зависимости, либо через вызов getBean(). Как правило, используется
//             для бинов с сохранением состояния(stateful)
//    request - Жизненный цикл экземпляра ограничен единственным HTTP запросом; для каждого нового HTTP запроса
//             создается новый экземпляр бина. Действует, только если вы используете web-aware ApplicationContext
//    session - Жизненный цикл экземпляра ограничен в пределах одной и той же HTTP Session. Действует, только если
//             вы используете web-aware ApplicationContext
//    global session - Жизненный цикл экземпляра ограничен в пределах глобальной HTTP Session(обычно при использовании
//             portlet контекста). Действует, только если вы используете web-aware ApplicationContext
//    application - Жизненный цикл экземпляра ограничен в пределах ServletContext. Действует, только
//             если вы используете web-aware ApplicationContext
}
